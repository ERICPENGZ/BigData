
数据分片与路由

	一.哈希

		1.hash分片方式_RoundRobin
			一层取模

		2.虚拟桶
			Membase：在待存储记录和物理机之间引入了虚拟桶层，第一层：所有记录首先通过哈希函数映射到对应的虚拟桶，记录和虚拟桶是多对一的映射关系。一个backet包含多条record。第二层：虚拟桶到物理机，通过查表来实现的。Membase通过内存表来管理这层映射关系。

		3.一致哈希性算法
			分布式哈希表DHT用到的一种实现方式。
			m = 5，哈希空间：0~31.

		4.范围分片
			首先将所有记录的主键key进行排序，然后再排好序的主键空间里将记录划分成数据分片，每个数据分片存储有序的主键空间片段内的所有记录。在实现时，保持一个分片的映射表，表的每一项记录数据分片的最小主键及其对应的物理主机地址。

==================================================

数据复制与一致性

	一.基本原则与设计理念

		1.CAP_不可兼得
			强一致性（更新操作的效果与只有单份数据是一致的），可用性（限定延时），分区容忍性。
			CP：数据无副本，满足高可用和分区容忍
			AC：没有网络分区，满足同时更新和延时限定
			AP：跟AC存在权衡。存在P（发生了网络分区导致两台机器无法通信），则返回数据必然会加长延时或者存在不一致性。

		2.三个步骤
			1.首先识别网络分区的发生。2.进入分区的模式。3.恢复数据的一致性和弥补分区模式中产生的错误。

		3.ACID_针对数据库系统
			1.原子性：事务全部执行，要么不执行
			2.一致性：A+B=100，A改，B也要响应修改。满足一致性约束
			3.事务独立（隔离性）：事务之间需要序列化执行。事务执行时互不影响。
			4.持久性：运行成功后，对系统的更新状态是永久的，不会无故的回滚

		4.Base原则_针对云平台/nosql系统
			1.基本可用：允许偶尔的fail
			2.软状态：不要求完全一致，处于有状态和无状态之间的中间属性。
			3.最终一致：在给定的时间窗口内达到一致
			summary：牺牲了强一致性来保持高可用性。

		5.CAP/ACID/BASE的关系
			1.ACID和CAP中c,ACID中的C的一致性要求比CAP中的广。ACID：数据操作的一致性，在出现网络分区的时候不可能完成。CAP：强一致性，多副本对外表现为单副本
			2.当出现网络分区时，ACID中的隔离性要求只能在一个分区内执行：因为数据序列化需要通信。
			3.当出现分区时，每个分区尽可能的执行CAP原则

		6.幂等性
			f(f(x)) = f(x);
			调用方反复执行同一个操作与执行一次操作的效果相同。在调用方执行操作，但因为网络原因无法得到调用成功的响应时，会认为调用失败而在此调用。


	二.一致性模型
	---------------------
		一致性关系图(p41)
		
		1.强一致性：
			如果某个进程对数据进行了更新，那么以后的后续的操作都会以这个更新后的值为基准，直到这个数据被其他进程改变为止

		2.最终一致性：
			在一个时间片段后可以保证强一致性。不一致窗口：为了达到高可用的性，同一份数据通常会被存储到多个节点，不同进程可能操作数据的不同备份，当某进程对数据做出了修改以后，需要一定时间来将这个新值传递给其他节点。

		3.因果一致性：
			A,B,C三个进程，A在修改了数据后，以notify()的形式通知B进程数据已被修改，则B以后都用这个新值，则A,B存在因果一致性。但C仍可能读到A的旧值

		4.读你所写一致性：
			3的特例：A给自己发notify，其他进程不收影响，可能读到旧值

		5.会话一致性：
			在同一个会话内，保持4一致

		6.单调读一致：
			某个进程一旦读到新值，它将不会再读到老值

		7.单调写一致：

	三.副本更新策略
	-----------------
		1.同时更新：
			情形1：不通过一致性协议同时更新，但会出现数据不一致（每个机器接受到的update顺序可能不一样）
			情形2：一致性协议处理请求顺序，可以保证一致性，但延时会增加

		2.主从更新：
			数据的副本存在master和从副本。则对数据的更新操作首先提交到master，再用master更新到从副本。如果存在多个更新顺序。则主副本决定更新顺序，从副本也遵从这个更新顺序。根据master通知从副本的不同机制来分为三个情形：

				情形1：同步，master等待所有从副本更新完成后才确认更新操作完成。保证强一致性，但存在较大的延时。

				情形2：异步，master在通知之前就可确认更新操作，但为了防止master崩掉，会记录更新操作。请求延时和一致性的权衡取决于读的响应方式：
						A:所有读请求必须先交给master
						B:从可以响应，但会带来不一致问题（zookeeper）

				情形3：混合，master同步更新部分从节点，卡夫卡

		3.任意节点更新：
			任意节点都可应响应请求。


	四.一致性协议
	-------------------
		1.两段提交协议：
			两个实体：一个协调者，多个参与者。协调者：分布式事务的特殊的管理协调作用
			顾名思义：提交划分为两个阶段：1.表决阶段 2.提交阶段
					A:表决阶段
						1.协调者视角：向所有参与者发送vote_request消息
						2.参与者视角：收到vote_request后返回vote_commit消息，表示已经做好准备，否则返回vote_abort,告知协调者现在不能提交事务的：“可能”
					B:提交阶段
						【协调者视角】：收集A阶段的表决信息。若一致可以提交：最终提交。返回global_commit			    ,通知参与者本地提交。若不一致：取消事务，向所有参与者广播 				 global_abort通知事务取消
						[参与者视角]：取决于收到的协调者发来的信息
			有限状态机 p48

			应对阻塞：超时判断机制。参与者互询机制。（原理）
					 超时判断：
					 		A:协调者处于wait时间过长（没收到所有的返回消息），强制中断
					 		B：参与者init：等待协调者vote_request消息，超时，简单的本地中断事务，发	送vote_abord消息
					 参与者互询机制：
					 		参与者ready的情况（不知道外面什么情况），需要问同伴
					 		A：同伴已经收到commit了，则自身转为commit
					 		B：同伴是abort，转为abort
					 		C：同伴init，abort
					 		D：同伴也ready了，再问其他同伴
					 		summary：只要同伴是commit，init，abort，自己就能做出判断，若都是ready，			则崩掉


		2.向量时钟：
			






















